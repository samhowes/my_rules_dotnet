package dotnet

import (
	"fmt"
	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	bzl "github.com/bazelbuild/buildtools/build"
	"log"
	"strings"
)

// ============ resolve.Resolver implementation ============

// Imports returns a list of ImportSpecs that can be used to import the rule
// r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
func (d dotnetLang) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	info := getInfo(c)
	l := fmt.Sprintf(info.Project.FileLabel.String())
	log.Printf("imports: %s", l)
	return []resolve.ImportSpec{{
		Lang: languageName,
		Imp:  l,
	}}
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. Information about imported libraries is returned for each
// rule generated by language.GenerateRules in
// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
// the appropriate language-specific equivalent) for each import according to
// language-specific rules and heuristics.
func (d dotnetLang) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, importsRaw interface{}, from label.Label) {
	var comments []string
	var deps []string
	for _, depRaw := range importsRaw.([]interface{}) {
		dep := depRaw.(label.Label)
		results := ix.FindRulesByImportWithConfig(c, resolve.ImportSpec{Lang: languageName, Imp: dep.String()}, languageName)
		if len(results) > 1 {
			labels := make([]string, len(results))
			for i, r := range results {
				labels[i] = r.Label.String()
			}
			log.Panicf("ambigous project path detected. This should not happen, please file an issue. \n"+
				"project path: %s\n"+
				"results: %s", dep, strings.Join(labels, "\n"))
		}
		if len(results) == 0 {
			comments = append(comments, "# gazelle: could not find project file at %s", dep.String())
			continue
		}

		res := results[0]

		deps = append(deps, res.Label.String())
	}

	if len(deps) > 0 || len(comments) > 0 {
		r.SetAttr("deps", deps)
		if len(comments) > 0 {
			attr := r.Attr("deps")
			aComments := attr.Comment()
			for _, c := range comments {
				aComments.Before = append(aComments.Before, bzl.Comment{Token: c})
			}

		}
	}

}
