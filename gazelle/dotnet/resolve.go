package dotnet

import (
	"fmt"
	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	bzl "github.com/bazelbuild/buildtools/build"
	"log"
	"strings"
)

// ============ resolve.Resolver implementation ============

// Imports returns a list of ImportSpecs that can be used to import the rule
// r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
func (d dotnetLang) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	info := getInfo(c)
	l := fmt.Sprintf(info.Project.FileLabel.String())
	log.Printf("imports: %s", l)
	return []resolve.ImportSpec{{
		Lang: languageName,
		Imp:  l,
	}}
}

type projectDep struct {
	Label     label.Label
	Comments  []string
	IsPackage bool
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. Information about imported libraries is returned for each
// rule generated by language.GenerateRules in
// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
// the appropriate language-specific equivalent) for each import according to
// language-specific rules and heuristics.
func (d dotnetLang) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, importsRaw interface{}, from label.Label) {
	var missing [][]bzl.Comment
	var deps []bzl.Expr
	for _, depRaw := range importsRaw.([]interface{}) {
		dep := depRaw.(projectDep)
		var comments []bzl.Comment

		for _, c := range dep.Comments {
			comments = append(comments, bzl.Comment{Token: c})
		}
		l, comments := findDep(c, ix, dep, comments)

		if l == nil {
			missing = append(missing, comments)
		} else {
			dExpr := bzl.StringExpr{Value: l.String()}
			deps = append(deps, &dExpr)
		}
	}

	if len(deps) == 0 && len(missing) == 0 {
		return
	}

	expr := bzl.ListExpr{List: deps}
	if len(missing) > 0 {
		var commented *bzl.Comments
		if len(deps) > 0 {
			commented = deps[0].Comment()
		} else {
			commented = expr.End.Comment()
		}
		for _, cl := range missing {
			commented.Before = append(commented.Before, cl...)
		}
	}

	r.SetAttr("deps", &expr)
}

func findDep(c *config.Config, ix *resolve.RuleIndex, dep projectDep, comments []bzl.Comment) (*label.Label, []bzl.Comment) {
	if dep.Label == label.NoLabel {
		return nil, comments
	}
	if dep.IsPackage {
		return &dep.Label, comments
	}
	spec := resolve.ImportSpec{Lang: languageName, Imp: dep.Label.String()}
	results := ix.FindRulesByImportWithConfig(c, spec, languageName)
	if len(results) > 1 {
		labels := make([]string, len(results))
		for i, r := range results {
			labels[i] = r.Label.String()
		}
		log.Panicf("ambigous project path detected. This should not happen, please file an issue. \n"+
			"project path: %s\n"+
			"results: %s", dep.Label.String(), strings.Join(labels, "\n"))
	} else if len(results) == 0 {
		c := fmt.Sprintf("# gazelle: could not find project file at %s", dep.Label.String())
		comments = append(comments, bzl.Comment{Token: c})
		return nil, comments
	}
	return &results[0].Label, comments
}
